Smart Pointer
    โดยปกติแล้ว pointer จะมี 2 คุณสมบัติ คือ
        1. ข้อมูลที่เก็บอยู่ในตัวแปร (*)
        2. ที่อยู่ของตัวแปร (&)
    แต่จะเกิดปัญหา คือ อาจชี้ไปยิงตำแหน่งที่ไม่มีข้อมูลอยู่จริง หรือ ข้อมูลอยู่ ๆ ก็หายไปเอง
    ซึ่ง smart pointer จะเกิดขึ้นมาเพื่อแก้ปัญหาดังกล่าว
    
    ตัวแปรของเรา ปกติแล้วจะเก็บข้อมูลไว้หนึ่งในสองที่นี้
        1. stack:   ใช้สำหรับเก็บข้อมูลจากการเขียนชุดคำสั่งปกติทั่วไป เช่น การประกาศตัวแปร แต่จะไม่สามารถใช้กับข้อมูล
                    ที่มีขนาดที่ไม่แน่นอนไม่ได้ โดยเราจะย้ายข้อมูลเหล่านั้นไปเก็บไว้ใน heap แทน ละเก็บ pointer
                    reference ไว้ที่ stack โดย pointer reference คือ memory address ของข้อมูลที่เก็บ
                    อยู่ใน heap
        2. heap:    สามารถจัดเก็บข้อมูลได้ยืดหยุ่น สามารถจอง memory ได้เรื่อย ๆ

    **  จังหวะแรกสุด ทุกตัวแปรจะถูกเก็บไว้ใน stack โดยข้อมูลที่ของตัวแปรจะเก็บอยู่ใน stack หรือ heap 
        ขึ้นอยู่กับว่ามัน dynamic ได้หรือไม่

    ** ใน rust ถ้าหากข้อมูลใน stack ที่เป็น pointer reference ไปหาข้อมูลใน heap ถูกลบ ข้อมูลใน heap จะภูกลบด้วย

    โดย rust จะมีเครื่องมือให้ใช้ดังนี้
        1. Box      ใช้สำหรับประกาศว่าตัวแปรนี้จะถูกเก็ยอยู่ใน heap
        2. Share ownership Rc<T>, Arc<T> การมี owner ร่วมกัน
        3. RefCell<T>, Mutex<T> เปลี่ยนข้อมูลแปลงข้อมูล
    
    Box<T> 
        เป็น smart pointer โดยจะใช้สำหรับจากเดิมที่อยู่ใน stack มาเก็บใน heap
        ตัวอย่างชุดคำสั่ง
            let x = Box::new(10);
            println!("ค่าใน box คือ: {}, x);
        โดยมากจะใช้ในกรณีที่เราต้องการจองข้อมูลไว้ใน heap แต่ไม่รู้ว่าจะต้องจองไว้เท่าไหร่
        
    Rc<T> (reference count)
        จัดเก็บข้อมูลไว้บน heap เหมือนเดิม โดยจะเพิ่มความสามารถให้เราสามารถแชร์ ownership ได้ด้วย
        โดยเมื่อไม่มี ownership อันไหนชี้มาหาข้อมูลที่อยู่บน heap แล้ว จะถูก free โดยอัตโนมัติ

        โดยคุณสมบัติหลัก ๆ คือ   
            1. ใช้สำหรับสถาณการณ์ที่ต้องการแชร์ข้อมูลเดียวกันระหว่างหลายตัวแปรใน thread เดียว
            2. ทำงานในรูปแบบ immtable shared ownership (ค่าใน rc เปลี่ยนแปลงข้อมูลไม่ได้ตรง ๆ)

        Rc::clone
            เป็นการ clone ownership
            โดยเจ้าของ ownership จะยังเป็น rc ที่สร้างข้อมูลขึ้นมา
            แต่ว่าได้ทำการแชร์ ownership ให้กับผู้ที่ทำการ clone ไปด้วย

    RefCell<T>
        เป็น smart pointer ที่ทำให้เราสามารถเปลี่ยนแปรงค่าภายในได้ แม้วันมันจะอยู่ภายใต้ immtable ก็ตาม
        โดยการเปลี่ยนแปรงค่าจะถูกตรวจสอบโดย runtime ไม่ใช่ compile
         
        คุณสมบัติ 
            1. Interior Mutability: สามารถเปลี่ยนค่าภายในได้ แม่ว่าจะเป็น immutable
            2. Borrow Checking ใน Runtime: ระบบจะตรวจสอบกฏ borrwing ใน runtime โโย 
                2.1 เราสามารถ Borrow ค่าแบบ immtable ได้หลายครั้ง (borrow())
                2.2 เราสามารถ borrow ค่าแบบ mutable ได้ครั้งเดียว (borrow_mut())

    Weak<T>
        เป็น smart pointer ที่ใช้ร่วมกับ Rc โดยจะป้องปันปัญหา วงจนอ้างอิง (cyclic reference)
        ซึ่งอาจทำให้หน่วจความจำไม่ถูกปล่อย (memory leak)

        โดย Weak<T> จะสร้าง reference ไปยังค่าใน Rc<T> โดยไม่เพิ่ม reference count ของค่าใน Rc<T>

        คุณสมบัติ
            1.  ไม่มี string ownership: Weak ไม่ได้เป็น owner ของค่า แต่สามารถอ้างอิงค่าใน Rc ได้ 
            2.  ไม่เพิ่ม reference count 
            3.  Upgrad: สามารถอัปเกรด Weak<T> เป็ฯ Rc<T>> ด้วย .upgrad() เพื่อใช้งานค่าที่ชี้ไป หากค่าถูก free ไปแล้ว
                จะคืนค่า none

    ** ไม่เหมาะกับการใช้งานกับ multithread